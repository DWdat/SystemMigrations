<?php

/**
 * ProcessWire System Migrations
 *
 * @author Rasmus Schultz
 * @website http://blog.mindplay.dk/
 * @license GPL v3
 */

/**
 * System Migrations Module
 *
 * This module is responsible for recording changes to Fields and Templates.
 */
class SystemMigrations extends WireData implements Module, ConfigurableModule
{
    /**
     * @var string path to data root-folder (where migration files are stored)
     * @see __destruct()
     */
    public $data_path;

    /**
     * @var bool if true, the module is currently recording changes
     */
    public $recording = true;

    /**
     * @var array list of Field properties and settings at the time of loading
     */
    protected $old_data = array();

    /**
     * @var array list of recorded function-calls, nested arrays like:
     *            array('method' => $method, 'params' => $params)
     * @see record()
     */
    protected $recorded = array();
    
    /**
     * Registry filename
     * @see getMigrations()
     */
    const REGISTRY_FILENAME = '.installed';
    
    /**
     * @return array module information
     */
    public static function getModuleInfo()
    {
        return array(
            'title'      => 'Migrations',
            'author'     => 'Rasmus Schultz',
            'version'    => 100,
            'summary'    => 'Records and integrates changes to Templates and Fields.',
            'permission' => 'template-admin',
            'href'       => 'https://github.com/mindplay-dk/SystemMigrations',
            'singular'   => true,
            'autoload'   => true,
            'installs'   => array('SystemMigrationsAdmin'),
        );
    }

    /**
     * Initialize module settings.
     */
    public function __construct()
    {
        $this->addHookAfter('Fields::load', $this, 'hookFieldLoaded');
        $this->addHookAfter('ProcessField::fieldSaved', $this, 'hookFieldSaved');
        $this->addHookAfter('ProcessField::fieldAdded', $this, 'hookFieldAdded');
        $this->addHookAfter('ProcessField::fieldDeleted', $this, 'hookFieldDeleted');
        #$this->addHookAfter('ProcessField::fieldChangedType', $this, 'hookFieldChangedType');

        $this->data_path = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'data';
    }

    /**
     * Method to initialize the module.
     *
     * This is called after ProcessWire's API is fully ready for use and hooks. It is called at the end of the
     * bootstrap process. This is before PW has started retrieving or rendering a page. If you need to have the
     * API ready with the $page ready as well, then see the ready() method below this one.
     */
    public function init()
    {
        // ...
    }

    /**
     *
     */
    public function ready()
    {
        if ($this->page->template != 'admin') {
            return;
        }
        
        // ...
    }

    /**
     * Record a function-call as part of a migration
     *
     * @param string $method method-name
     * @param array $params method arguments
     */
    protected function record($method, array $params)
    {
        if ($this->recording) {
            $this->recorded[] = array('method' => $method, 'params' => $params);
        }
    }

    /**
     * @param HookEvent $event
     *
     * @see WireSaveableItems::___load()
     * @see Fields::___load()
     */
    public function hookFieldLoaded(HookEvent $event)
    {
        /**
         * @var WireArray $fields
         */

        #$event->object

        $fields = $event->argumentsByName('items');

        foreach ($fields as $field) {
            $this->old_data[$field->id] = $this->getFieldData($field);
        }
    }

    /**
     * @param HookEvent $event
     *
     * @see ProcessField::___fieldSaved()
     */
    public function hookFieldSaved(HookEvent $event)
    {
        /**
         * @var Field $field
         */

        $field = $event->argumentsByName('field');
        
        $data = $this->getFieldData($field);
        
        $old_data = $this->old_data[$field->id];

        $diff = array();

        foreach ($old_data as $name => $value) {
            if ($value != @$data[$name]) {
                $diff[$name] = $data[$name];
            }
        }
        
        foreach ($data as $name => $value) {
            if ($value != @$old_data[$name]) {
                $diff[$name] = $value;
            }
        }
        
        if (count($diff)) {
            $this->record('updateField', array(
                    'name' => $old_data['name'],
                    'data' => $diff)
            );
        }
    }

    /**
     * @param HookEvent $event
     *
     * @see ProcessField::___fieldAdded()
     */
    public function hookFieldAdded(HookEvent $event)
    {
        /**
         * @var Field $field
         */

        $field = $event->argumentsByName('field');

        $data = $this->getFieldData($field);

        $name = $data['name'];

        unset($data['name']);

        $this->record('addField', array(
                'name' => $name,
                'type' => $field->type->name,
                'data' => $data)
        );
    }
    
    /**
     * @param HookEvent $event
     *
     * @see ProcessField::___fieldSaved()
     */
    public function hookFieldDeleted(HookEvent $event)
    {
        /**
         * @var Field $field
         */

        $field = $event->argumentsByName('field');

        $this->record('deleteField', array('name' => $field->name));
    }
    
    /**
     * Extract all important Field properties and settings
     *
     * @param Field $field
     * @return array
     */
    protected function getFieldData(Field $field)
    {
        $data = array();

        foreach ($field as $name => $value) {
            $data[$name] = $value;
        }
        
        $settings = $field->getTableData();
        
        unset($settings['data'], $settings['type'], $settings['prevTable'], $settings['prevFieldtype']);
        
        foreach ($settings as $name => $value) {
            $data[$name] = $value;
        }
        
        $data['name'] = $field->name;

        // IDs cannot change and are not interesting to us:
        unset($data['id']);
        
        // ignore default columnWidth if set - see Fields::___saveFieldgroupContext()
        if (isset($data['columnWidth']) && ($data['columnWidth'] == 100)) {
            unset($data['columnWidth']);
        }
        
        return $data;
    }

    /**
     * Builds the Module configuration form.
     *
     * @param array $data module configuration values
     *
     * @return InputfieldsWrapper|InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data)
    {
        $modules = Wire::getFuel('modules');
        
        $fields = new InputfieldWrapper();
        
        $markup = wire('modules')->get('InputfieldMarkup');
        
        $markup->markupText = '<h2>System Migrations</h2><p>Please select &quot;Migrations&quot; from the &quot;Setup&quot; menu...</p>';
        
        $fields->append($markup);

        return $fields;
    }
    
    /**
     * Load list of migrations available on this system
     *
     * @return ArrayObject
     */
    public function getMigrations()
    {
        /**
         * @var ArrayObject $migrations
         */

        static $migrations;
        
        if ($migrations === null) {
            $migrations = new ArrayObject();

            $registry_path = $this->data_path . DIRECTORY_SEPARATOR . self::REGISTRY_FILENAME;
            
            if (file_exists($registry_path)) {
                // load registry:
                $migrations->exchangeArray(json_decode(file_get_contents($registry_path), true));
                
                // sanitize the registry:
                foreach ($migrations as $existing_filename => $installed) {
                    if (! file_exists($this->data_path . DIRECTORY_SEPARATOR . $existing_filename)) {
                        unset($migrations[$existing_filename]); // physical file has been removed
                    }
                }
            }
            
            // update registry:
            foreach (glob($this->data_path.'/*.json') as $migration_path) {
                $migration_filename = basename($migration_path);
                
                if (! array_key_exists($migration_filename, $migrations)) {
                    $migrations[ $migration_filename ] = false; // physical file detected - add to registry
                }
            }
        }
        
        return $migrations;
    }

    /**
     * Flag a specified migration-file as having been applied to this system
     *
     * @param string $filename
     */
    public function recordAppliedMigration($filename)
    {
        // record applied migration:

        $registry = $this->getMigrations();

        $registry[$filename] = true;

        file_put_contents(
            /* $filename: */ $this->data_path . DIRECTORY_SEPARATOR . self::REGISTRY_FILENAME,
            /* $data */ json_encode($registry)
        );
    }

    /**
     * Write any recorded changes to a new migration file.
     */
    public function __destruct()
    {
        list($n, $time) = explode('.', microtime(true));

        $filename = date('Y-m-d-H-i-s-')
            . str_pad(substr($time,-4), 4, '0', STR_PAD_LEFT) . '-'
            . substr(md5(rand(0,9999999).microtime(true)),0,8) . '.json';
        
        if (count($this->recorded)) {
            file_put_contents(
                /* $filename: */ $this->data_path . DIRECTORY_SEPARATOR . $filename,
                /* $data: */ json_encode($this->recorded)
            );
            
            $this->recordAppliedMigration($filename);
        }
    }
}
