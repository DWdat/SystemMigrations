<?php

/**
 * ProcessWire System Migrations
 *
 * @author Rasmus Schultz
 * @website http://blog.mindplay.dk/
 * @license GPL v3
 */

/**
 * System Migrations Module
 *
 * This module is responsible for recording changes to Fields and Templates.
 */
class SystemMigrations extends WireData implements Module, ConfigurableModule
{
    /**
     * @var string path to data root-folder (where migration files are stored)
     * @see __destruct()
     */
    public $data_path;

    /**
     * @var bool if true, the module is currently recording changes
     */
    public $recording = true;

    /**
     * @var array list of Field properties and settings at the time of loading
     */
    protected $field_data = array();

    /**
     * @var array list of Template properties and settings at the time of loading
     */
    protected $template_data = array();

    /**
     * @var array list of recorded function-calls, nested arrays like:
     *            array('method' => $method, 'params' => $params)
     * @see record()
     */
    protected $recorded = array();
    
    /**
     * Registry filename
     * @see getMigrations()
     */
    const REGISTRY_FILENAME = '.installed';
    
    /**
     * @return array module information
     */
    public static function getModuleInfo()
    {
        return array(
            'title'      => 'Migrations',
            'author'     => 'Rasmus Schultz',
            'version'    => 100,
            'summary'    => 'Records and integrates changes to Templates and Fields.',
            'permission' => 'template-admin',
            'href'       => 'https://github.com/mindplay-dk/SystemMigrations',
            'singular'   => true,
            'autoload'   => true,
            'installs'   => array('SystemMigrationsAdmin'),
        );
    }

    /**
     * Initialize module settings.
     */
    public function __construct()
    {
        // Record changes to Fields:
        $this->addHookAfter('Fields::load', $this, 'hookFieldLoaded');
        $this->addHookAfter('Fields::saved', $this, 'hookFieldSaved');
        $this->addHookAfter('Fields::added', $this, 'hookFieldAdded');
        $this->addHookAfter('Fields::deleted', $this, 'hookFieldDeleted');
        $this->addHookAfter('Fields::changedType', $this, 'hookFieldChangedType');
        
        // Record changes to Templates:
        $this->addHookAfter('Templates::load', $this, 'hookTemplateLoaded');
        $this->addHookAfter('Templates::saved', $this, 'hookTemplateSaved');
        $this->addHookAfter('Templates::added', $this, 'hookTemplateAdded');

        // Flush changes after page rendered and/or after redirect:
        $this->addHookBefore('Session::redirect', $this, 'flushChanges');
        $this->addHookAfter('ProcessPageView::finished', $this, 'flushChanges');

        // Configure path to migrations data:
        $this->data_path = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'data';
    }

    /**
     * Method to initialize the module.
     *
     * This is called after ProcessWire's API is fully ready for use and hooks. It is called at the end of the
     * bootstrap process. This is before PW has started retrieving or rendering a page. If you need to have the
     * API ready with the $page ready as well, then see the ready() method below this one.
     */
    public function init()
    {
        // Hi there!
    }

    /**
     * Record a function-call as part of a migration
     *
     * @param string $method method-name
     * @param array $params method arguments
     */
    protected function record($method, array $params)
    {
        if ($this->recording) {
            $this->recorded[] = array('method' => $method, 'params' => $params);
        }
    }

    /**
     * @param HookEvent $event
     *
     * @see WireSaveableItems::___load()
     * @see Fields::___load()
     */
    public function hookFieldLoaded(HookEvent $event)
    {
        /**
         * @var WireArray $fields
         */

        $fields = $event->argumentsByName('items');

        foreach ($fields as $field) {
            $this->field_data[$field->id] = $this->getFieldData($field);
        }
    }

    /**
     * @param HookEvent $event
     *
     * @see Fields::___saved()
     */
    public function hookFieldSaved(HookEvent $event)
    {
        /**
         * @var Field $field
         */
        
        $field = $event->argumentsByName('item');
        
        $new_data = $this->getFieldData($field);
        
        $old_data = $this->field_data[$field->id];

        $updated = array();

        $removed = array();

        foreach ($old_data as $name => $value) {
            if (array_key_exists($name, $new_data) && $value != $new_data[$name]) {
                $updated[$name] = $new_data[$name];
            }
        }

        foreach ($new_data as $name => $value) {
            if (array_key_exists($name, $old_data)) {
                if ($value != $old_data[$name]) {
                    $updated[$name] = $value;
                }
            } else {
                if (!empty($old_data[$name])) {
                    $removed[] = $name;
                }
            }
        }

        if (count($updated)) {
            $this->record(
                'updateField',
                array(
                    'name' => $old_data['name'],
                    'updated' => $updated,
                    'removed' => $removed,
                )
            );
        }
    }

    /**
     * @param HookEvent $event
     *
     * @see Fields::added()
     */
    public function hookFieldAdded(HookEvent $event)
    {
        /**
         * @var Field $field
         */

        $field = $event->argumentsByName('item');

        $data = $this->getFieldData($field);

        $name = $data['name'];

        unset($data['name']);

        $this->record(
            'addField',
            array(
                'name' => $name,
                'type' => $field->type->name,
                'data' => $data
            )
        );
    }
    
    /**
     * @param HookEvent $event
     *
     * @see Fields::___deleted()
     */
    public function hookFieldDeleted(HookEvent $event)
    {
        /**
         * @var Field $field
         */

        $field = $event->argumentsByName('item');

        $this->record('deleteField', array('name' => $field->name));
    }

    /**
     * @param HookEvent $event
     *
     * @see Fields::___changedType()
     */
    public function hookFieldChangedType(HookEvent $event)
    {
        /**
         * @var Field $field
         */

        $field = $event->argumentsByName('item');
        
        // TODO: get the $fromType argument, record the previous type, check it when applying this change

        $this->record('changeFieldType', array('name' => $field->name, 'type' => $field->type->name));
    }

    /**
     * Extract all important Field properties and settings
     *
     * @param Field $field
     * @return array
     */
    protected function getFieldData(Field $field)
    {
        $data = array();

        foreach ($field as $name => $value) {
            $data[$name] = $value;
        }
        
        $settings = $field->getTableData();
        
        unset($settings['data'], $settings['type'], $settings['prevTable'], $settings['prevFieldtype']);
        
        foreach ($settings as $name => $value) {
            $data[$name] = $value;
        }
        
        $data['name'] = $field->name;

        // IDs cannot change and are not interesting to us:
        unset($data['id']);
        
        // ignore default columnWidth if set - see Fields::___saveFieldgroupContext()
        if (isset($data['columnWidth']) && ($data['columnWidth'] == 100)) {
            unset($data['columnWidth']);
        }
        
        return $data;
    }

    /**
     * Extract all important Template properties and settings
     *
     * @param Template $template
     * @return array
     */
    protected function getTemplateData(Template $template)
    {
        $settings = $template->getTableData();

        // pull ['data'] from $settings and merge it's contents into $settings :
        $data = $settings['data'];
        unset($settings['data']);
        $data = array_merge($settings, $data);

        // include template name in data:
        $data['name'] = $template->name;

        // exclude Template ID, which cannot change:
        unset($data['id']);

        return $data;
    }

    /**
     * @param HookEvent $event
     *
     * @see WireSaveableItems::___load()
     * @see Templates::___load()
     */
    public function hookTemplateLoaded(HookEvent $event)
    {
        /**
         * @var TemplatesArray $templates
         */

        $templates = $event->argumentsByName('items');

        foreach ($templates as $template) {
            $this->template_data[$template->id] = $this->getTemplateData($template);
        }
    }

    /**
     * @param HookEvent $event
     *
     * @see WireSaveableItems::___saved()
     * @see Templates::___saved()
     */
    public function hookTemplateSaved(HookEvent $event)
    {
        $template = $event->argumentsByName('item');

        $old_data = $this->template_data[$template->id];

        $new_data = $this->getTemplateData($template);

        $updated = array();

        $removed = array();

        foreach ($old_data as $name => $value) {
            if (array_key_exists($name, $new_data) && $value != $new_data[$name]) {
                $updated[$name] = $new_data[$name];
            }
        }

        foreach ($new_data as $name => $value) {
            if (array_key_exists($name, $old_data)) {
                if ($value != $old_data[$name]) {
                    $updated[$name] = $value;
                }
            } else {
                if (!empty($old_data[$name])) {
                    $removed[] = $name;
                }
            }
        }

        if (count($updated)) {
            $this->record(
                'updateTemplate',
                array(
                    'name' => $old_data['name'],
                    'updated' => $updated,
                    'removed' => $removed,
                )
            );
        }
    }

    /**
     * @param HookEvent $event
     *
     * @see Templates::added()
     */
    public function hookTemplateAdded(HookEvent $event)
    {
        /**
         * @var Template $field
         */

        $template = $event->argumentsByName('item');

        $data = $this->getTemplateData($template);

        $name = $data['name'];

        unset($data['name']);

        $this->record(
            'addTemplate',
            array(
                'name' => $name,
                'data' => $data
            )
        );
    }

    /**
     * Builds the Module configuration form.
     *
     * @param array $data module configuration values
     *
     * @return InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data)
    {
        $fields = new InputfieldWrapper();
        
        $markup = wire('modules')->get('InputfieldMarkup');
        
        $markup->markupText = '<h2>System Migrations</h2><p>Please select &quot;Migrations&quot; from the &quot;Setup&quot; menu...</p>';
        
        $fields->append($markup);

        return $fields;
    }
    
    /**
     * Load list of migrations available on this system
     *
     * @return ArrayObject
     */
    public function getMigrations()
    {
        /**
         * @var ArrayObject $migrations
         */

        static $migrations;
        
        if ($migrations === null) {
            $migrations = new ArrayObject();

            $registry_path = $this->data_path . DIRECTORY_SEPARATOR . self::REGISTRY_FILENAME;
            
            if (file_exists($registry_path)) {
                // load registry:
                $migrations->exchangeArray(json_decode(file_get_contents($registry_path), true));
                
                // sanitize the registry:
                foreach ($migrations as $existing_filename => $installed) {
                    if (! file_exists($this->data_path . DIRECTORY_SEPARATOR . $existing_filename)) {
                        unset($migrations[$existing_filename]); // physical file has been removed
                    }
                }
            }
            
            // update registry:
            foreach (glob($this->data_path.'/*.json') as $migration_path) {
                $migration_filename = basename($migration_path);
                
                if (! array_key_exists($migration_filename, $migrations)) {
                    $migrations[ $migration_filename ] = false; // physical file detected - add to registry
                }
            }
        }
        
        return $migrations;
    }

    /**
     * Flag a specified migration-file as having been applied to this system
     *
     * @param string $filename
     */
    public function recordAppliedMigration($filename)
    {
        // record applied migration:

        $registry = $this->getMigrations();

        $registry[$filename] = true;

        file_put_contents(
            /* $filename: */ $this->data_path . DIRECTORY_SEPARATOR . self::REGISTRY_FILENAME,
            /* $data: */ json_encode($registry)
        );
    }

    /**
     * Write any recorded changes to a new migration file.
     *
     * @param HookEvent $event unused
     */
    public function flushChanges(HookEvent $event)
    {
        if (count($this->recorded)) {
            list($n, $time) = explode('.', microtime(true));

            $filename = date('Y-m-d-H-i-s-')
                . str_pad(substr($time,-4), 4, '0', STR_PAD_LEFT) . '-'
                . substr(md5(rand(0,9999999).microtime(true)),0,8) . '.json';
            
            file_put_contents(
                $this->data_path . DIRECTORY_SEPARATOR . $filename
                ,
                json_encode($this->recorded)
            );
            
            $this->recordAppliedMigration($filename);
        }
    }
}
