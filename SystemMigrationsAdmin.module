<?php

/**
 * This module is responsible for repeating changes to Fields and Templates.
 */
class SystemMigrationsAdmin extends Process
{ 
    const PAGE_NAME = 'migrations';

    /**
     * @return array module information
     */
    public static function getModuleInfo()
    {
        return array(
            'title'      => 'Migrations Admin',
            'author'     => 'Rasmus Schultz',
            'version'    => 100,
            'summary'    => 'Administration module for Migrations.',
            'permission' => 'template-admin',
            'requires'   => array('SystemMigrations'),
        );
    }

    /**
     * Method to initialize the module.
     *
     * This is called after ProcessWire's API is fully ready for use and hooks. It is called at the end of the
     * bootstrap process. This is before PW has started retrieving or rendering a page. If you need to have the
     * API ready with the $page ready as well, then see the ready() method below this one.
     */
    public function init()
    {
        $this->data_path = wire('modules')->SystemMigrations->data_path;
    }
    
    /**
     * Display migration status
     */
    public function ___execute()
    {
        /**
         * @var InputfieldWrapper $fields
         */

        $fields = new InputfieldWrapper();
        
        $html = "<h2>Pending Migrations</h2>\n";
        
        $first = true;
        
        $count = 0; $max = 100;
        
        $fast_forward = true;
        
        foreach ($this->getMigrations() as $filename => $installed) {
            if ($fast_forward && $installed) {
                continue; // fast foward past already installed migrations
            } else {
                $fast_forward = false;
            }
            
            if (++$count > $max) {
                $html .= "<pre>  More than $max migrations in registry...</pre>\n";
                break;
            }
            
            $migration_data = $this->loadMigration($filename);
            
            $html .= "<pre>" . ($installed ? '  ' : '* ') . htmlspecialchars($filename) . ' ' . htmlspecialchars($this->describe($migration_data));
            
            if (($installed === false) && $first) {
                $first = false;
                
                $status = $this->canApply($migration_data);
                
                $html .= " <- " . ($status === true ? "READY" : $status);
                
                $html .= "</pre>\n";
            }
        }
        
        if (!$first) {
            $html .= '<h3><a style="border:solid 1px black;border-radius:8px;padding:8px;background:white;" href="./apply" onclick="return confirm(\'Apply pending Migrations now?\');"><span>Apply Migrations</span></a></h3>';
        } else {
            $html .= '<h3>Your Fields &amp; Templates are up to date.</h3>';
        }
        
        $markup = wire('modules')->get('InputfieldMarkup');
        $markup->markupText = $html;
        
        $fields->append($markup);
        
        return $fields->render();
    }
    
    /**
     * Apply migrations
     */
    public function ___executeApply()
    {
        /**
         * @var SystemMigrations $module
         */

        $module = wire('modules')->get('SystemMigrations');

        $module->recording = false; // disable recording while we repeat pending changes

        $html = '<h2>Apply Migrations</h2>';

        foreach ($this->getMigrations() as $filename => $installed) {
            if ($installed === false) {
                $migration_data = $this->loadMigration($filename);
                
                $status = $this->canApply($migration_data);
                
                if ($status === true) {
                    $html .= '<pre>Applying ' . $filename . '</pre>';

                    $this->apply($migration_data);

                    $module->recordAppliedMigration($filename);
                } else {
                    $html .= '<pre>Aborted ' . $filename . ' : ' . htmlspecialchars($status) . '</pre>';

                    break; // break out of for-each loop
                }
            }
        }
        
        return $html;
    }
    
    /**
     * Install the setup menu shortcut
     */
    public function ___install()
    {
        $page = new Page();
        
        $page->template = 'admin';
        
        $page->title = 'Migrations';
        $page->name = self::PAGE_NAME; 
        $page->parent = $this->pages->get($this->config->adminRootPageID)->child('name=setup');

        $page->process = $this; 

        $page->save();
    }

    /**
     * Remove the setup menu shortcut
     */
    public function ___uninstall()
    {
        $moduleID = $this->modules->getModuleID($this); 
        
        $page = $this->pages->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME); 

        if ($page->id) {
            $page->delete();
        }
    }
    
    public function getMigrations()
    {
        return wire('modules')->SystemMigrations->getMigrations();
    }

    /**
     * Load data from a migration file
     *
     * @param string $migration_filename
     * @return array
     */
    protected function loadMigration($migration_filename)
    {
        return json_decode(file_get_contents($this->data_path . DIRECTORY_SEPARATOR . $migration_filename), true);
    }

    /**
     * @param array $migration_data
     * @return string a description of the migration contained in the given migration file
     */
    public function describe($migration_data)
    {
        $strings = array();

        foreach ($migration_data as $data) {
            $string = array();

            foreach ($data['params'] as $name => $value) {
                if (is_scalar($value)) {
                    $string[] = $name . ':' . strval($value);
                }
            }

            $strings[] = $data['method'] . '(' . implode(' ', $string) . ')';
        }

        return implode(', ', $strings);
    }

    /**
     * @param array $migration_data
     * @return bool|string
     */
    public function canApply($migration_data)
    {
        if (!is_array($migration_data) || count($migration_data) === 0) {
            return 'Invalid migration file';
        }

        foreach ($migration_data as $data) {
            $fn = 'can' . ucfirst($data['method']);
            
            if (! (method_exists($this, $fn) && method_exists($this, $data['method']))) {
                return 'Unsupported migration type: ' . $data['method'];
            }
        }
        
        return call_user_func_array(array($this, $fn), $data['params']);
    }

    /**
     * @param array migration data
     */
    public function apply($migration_data)
    {
        foreach ($migration_data as $data) {
            call_user_func_array(array($this, $data['method']), $data['params']);
        }
    }

    /**
     * @param string $name
     * @param array $updated
     * @param string[] $removed
     * @return bool|string true on success; or a string with an error-message
     *
     * @see SystemMigrations::hookFieldUpdated()
     */
    protected function canUpdateField($name, array $updated, array $removed)
    {
        if (wire('fields')->$name === null) {
            return "Undefined Field: $name";
        }
        
        return true;
    }

    /**
     * Apply updates to a Field
     *
     * The name is the preferred way to find an existing Field, since the ID could
     * differ on another system. The name is the current name, before applying the
     * update - if the field's name has changed, the new name is in $data['name']
     *
     * @param string $name the (current) name of the Field
     * @param array $updated
     * @param string[] $removed
     * @internal param array $data new properties and settings for the Field
     *
     * @see SystemMigrations::hookFieldUpdated()
     */
    protected function updateField($name, array $updated, array $removed)
    {
        /**
         * @var Field $field
         */

        $field = wire('fields')->$name;

        foreach ($updated as $name => $value) {
            $field->$name = $value;
        }

        foreach ($removed as $name) {
            unset($field->$name);
        }

        $field->save();
    }

    /**
     * @param string $name
     * @param string $type
     * @param array $data
     * @return bool|string true on success; or a string with an error-message
     *
     * @see SystemMigrations::hookFieldAdded()
     */
    protected function canAddField($name, $type, array $data)
    {
        if (wire('fields')->$name) {
            return "Field already exists: $name";
        }
        
        return true;
    }
        
    /**
     * Adds a new Field
     *
     * @param string $name the name of the new Field
     * @param string $type the Field type (class) name
     * @param array $data new properties and settings for the Field
     *
     * @see SystemMigrations::hookFieldAdded()
     */
    protected function addField($name, $type, array $data)
    {
        /**
         * @var Fields $fields
         */

        $fields = wire('fields');

        $field = new Field();
        $field->setName($name);
        $field->setFieldtype($type);

        foreach ($data as $name => $value) {
            $field->$name = $value;
        }

        $field->save();
    }

    /**
     * @param string $name
     * @return bool|string true on success; or a string with an error-message
     *
     * @see SystemMigrations::hookFieldDeleted()
     */
    protected function canDeleteField($name)
    {
        if (wire('fields')->$name === null) {
            return "Undefined Field: $name"; // is it necessary to consider this an error?
        }

        return true;
    }
    
    /**
     * Deletes an existing Field
     *
     * @param string $name the name of the deleted Field
     *
     * @see SystemMigrations::hookFieldDeleted()
     */
    protected function deleteField($name)
    {
        /**
         * @var Fields $fields
         * @var Field $field
         */

        $fields = wire('fields');

        $field = $fields->$name;

        $fields->delete($field);
    }

    /**
     * @param string $name
     * @param string $type
     * @return bool|string true on success; or a string with an error-message
     */
    protected function canChangeFieldType($name, $type)
    {
        /**
         * @var Field $field
         */

        $field = wire('fields')->$name;

        if ($field === null) {
            return "Undefined Field: $name";
        }

        if (wire('fieldtypes')->get($type) === null) {
            return "Unknown FieldType: $type";
        }

        // note that all we can do to assert this is going to work, is check that
        // the Field and FieldType exists - whether or not changing the FieldType
        // succeeds is not known until attempted.

        return true;
    }

    /**
     * Changes the type of an existing field
     *
     * @param string $name
     * @param string $type
     */
    protected function changeFieldType($name, $type)
    {
        /**
         * @var Field $field
         */

        $field = wire('fields')->$name;

        $field->setFieldtype($type);

        $field->save();
    }
}
